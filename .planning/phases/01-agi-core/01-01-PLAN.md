# Phase 01: AGI Core Build

## Goal

Implement the AGI core loop and components per `architecture.md` and `project/gemini.md`: perceive → recall → reason → plan → act → store. No demo; real, runnable, pluggable implementation.

## Deliverables

### 1. Core loop (`src/agi/core.py`)

- **Agent**: Holds memory, reasoner, planner, action registry; runs one tick per call.
- **TickInput**: Raw input + source (user|env|event).
- **TickOutput**: Observation (success, payload, error) and/or response; halt flag.
- **tick(agent, input)**: One full cycle: perceive → recall → reason → plan → act → store. Returns TickOutput.

### 2. Memory (`src/agi/memory/`)

- **Store** (interface): `recall(query, kind?)` → list of entries; `store(entries)` for semantic/episodic; working memory get/set.
- **Semantic**: Facts, relations; queryable, updatable (e.g. in-memory list or JSON file).
- **Episodic**: Events with timestamp and context; append-only (e.g. list or log).
- **Working**: Bounded (max 10 recent turns, 1 active goal, 1 focus). In-memory only.

Constraints from gemini: max 10 recent turns; 1 active goal; 1 focus entity.

### 3. Reasoner (`src/agi/reasoner.py`)

- **Reasoner** (interface): `reason(state)` → beliefs (facts, uncertainties), candidate actions, suggested plan step.
- Input: current utterance/state, recalled memory, active goal.
- Stateless per call; state lives in memory and loop.
- Default implementation: rule-based or trivial (return empty beliefs, single “respond” action) so the package runs without an LLM. Pluggable backend later.

### 4. Planner (`src/agi/planner.py`)

- **Planner** (interface): `plan(goal, beliefs, tools)` → ordered steps or single next step.
- Replan when observations diverge (caller compares observation to plan).
- Max plan depth: 20 steps (gemini). Optional subgoal or user confirmation beyond that.

### 5. Action (`src/agi/action/`)

- **Tool registry**: Register named tools with description, parameters, effect (read|write|external).
- **execute_tool(name, args)** → observation (success, payload, error).
- **Response**: Produce text or structured output (return as observation with type=response).
- At least one built-in tool (e.g. “respond” or “echo”) so the loop can terminate with a response.

### 6. Perceive (`src/agi/perceive.py`)

- **perceive(raw_input, source)` → normalized input (e.g. strip, normalize source to user|env|event).
- Single entry point for ingesting user message, sensor payload, or event.

### 7. Entry point (`src/agi/main.py`)

- **CLI**: Read from stdin or args; run loop until halt or max ticks; print response.
- Example: `python -m agi.main` or `agi "What is 2+2?"` → run perceive → recall → reason → plan → act → store until response or halt.

## Implementation notes

- All long-term state in memory (semantic, episodic, working); no hidden globals.
- One tick = one full cycle. Store after every act that yields an observation.
- Reasoner/planner timeouts: configurable; default 30s (or N/A for rule-based default).
- Tool safety: write/external tools explicit; read-only can be auto-selected when appropriate.
- Python ≥3.10; no required LLM/vector deps in core (optional backends later).

## Verification

- `python -m agi.main --help` or equivalent runs.
- One full tick with a trivial input produces a TickOutput (e.g. response or observation).
- Import: `from agi.core import Agent, tick, TickInput, TickOutput` works after implementation.
