#!/usr/bin/env node
/**
 * Dependency Vulnerability Tracking Dashboard
 * Tracks vulnerabilities over time and generates reports
 * 
 * Usage: node tools/automation/vulnerability-tracker.js [--report] [--dashboard]
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const PROJECT_DIR = path.join(__dirname, '../..');
const VULN_HISTORY_FILE = path.join(PROJECT_DIR, 'project/vulnerability-history.json');

class VulnerabilityTracker {
  constructor() {
    this.history = this.loadHistory();
    this.mode = this.detectMode();
  }

  detectMode() {
    const modeFile = path.join(PROJECT_DIR, 'project/mode-assessment.json');
    if (fs.existsSync(modeFile)) {
      const assessment = JSON.parse(fs.readFileSync(modeFile, 'utf-8'));
      return assessment.mode || 'M';
    }
    return 'M';
  }

  loadHistory() {
    if (fs.existsSync(VULN_HISTORY_FILE)) {
      return JSON.parse(fs.readFileSync(VULN_HISTORY_FILE, 'utf-8'));
    }
    return { scans: [], trends: {} };
  }

  async scan() {
    console.log('ðŸ” Scanning for vulnerabilities...\n');

    const scanResult = {
      timestamp: new Date().toISOString(),
      mode: this.mode,
      vulnerabilities: {}
    };

    // Node.js vulnerabilities
    await this.scanNodeVulnerabilities(scanResult);

    // Python vulnerabilities (if applicable)
    await this.scanPythonVulnerabilities(scanResult);

    // Go vulnerabilities (if applicable)
    await this.scanGoVulnerabilities(scanResult);

    // Rust vulnerabilities (if applicable)
    await this.scanRustVulnerabilities(scanResult);

    // Save scan result
    this.history.scans.push(scanResult);
    this.updateTrends();
    this.saveHistory();

    return scanResult;
  }

  async scanNodeVulnerabilities(result) {
    try {
      const packageJson = path.join(PROJECT_DIR, 'package.json');
      if (!fs.existsSync(packageJson)) {
        return;
      }

      try {
        const auditOutput = execSync('npm audit --json', {
          cwd: PROJECT_DIR,
          encoding: 'utf-8',
          stdio: 'pipe'
        });
        
        const audit = JSON.parse(auditOutput);
        if (audit.vulnerabilities) {
          const vulns = Object.values(audit.vulnerabilities);
          result.vulnerabilities.nodejs = {
            total: vulns.length,
            critical: vulns.filter(v => v.severity === 'critical').length,
            high: vulns.filter(v => v.severity === 'high').length,
            moderate: vulns.filter(v => v.severity === 'moderate').length,
            low: vulns.filter(v => v.severity === 'low').length,
            details: audit.vulnerabilities
          };
        }
      } catch (e) {
        // npm audit may fail, that's okay
      }
    } catch (error) {
      // Not a Node.js project
    }
  }

  async scanPythonVulnerabilities(result) {
    try {
      const requirementsTxt = path.join(PROJECT_DIR, 'requirements.txt');
      if (!fs.existsSync(requirementsTxt)) {
        return;
      }

      // Use safety or pip-audit if available
      try {
        const safetyOutput = execSync('safety check --json', {
          cwd: PROJECT_DIR,
          encoding: 'utf-8',
          stdio: 'pipe'
        });
        
        const safety = JSON.parse(safetyOutput);
        if (safety.vulnerabilities) {
          result.vulnerabilities.python = {
            total: safety.vulnerabilities.length,
            details: safety.vulnerabilities
          };
        }
      } catch (e) {
        // safety not installed or no vulnerabilities
      }
    } catch (error) {
      // Not a Python project or safety not available
    }
  }

  async scanGoVulnerabilities(result) {
    try {
      const goMod = path.join(PROJECT_DIR, 'go.mod');
      if (!fs.existsSync(goMod)) {
        return;
      }

      // Use govulncheck if available (Go 1.18+)
      try {
        const vulnOutput = execSync('go list -json -m all', {
          cwd: PROJECT_DIR,
          encoding: 'utf-8',
          stdio: 'pipe'
        });
        
        // Parse and check for known vulnerabilities
        // This is a simplified version - full implementation would use govulncheck
        result.vulnerabilities.go = {
          note: 'Go vulnerability scanning requires govulncheck (Go 1.18+)'
        };
      } catch (e) {
        // Error checking
      }
    } catch (error) {
      // Not a Go project
    }
  }

  async scanRustVulnerabilities(result) {
    try {
      const cargoToml = path.join(PROJECT_DIR, 'Cargo.toml');
      if (!fs.existsSync(cargoToml)) {
        return;
      }

      try {
        const auditOutput = execSync('cargo audit --json', {
          cwd: PROJECT_DIR,
          encoding: 'utf-8',
          stdio: 'pipe'
        });
        
        const audit = JSON.parse(auditOutput);
        if (audit.vulnerabilities) {
          result.vulnerabilities.rust = {
            total: audit.vulnerabilities.length,
            details: audit.vulnerabilities
          };
        }
      } catch (e) {
        // cargo-audit may not be installed
      }
    } catch (error) {
      // Not a Rust project
    }
  }

  updateTrends() {
    const trends = {
      nodejs: { critical: [], high: [], total: [] },
      python: { total: [] },
      go: { total: [] },
      rust: { total: [] }
    };

    this.history.scans.forEach(scan => {
      Object.entries(scan.vulnerabilities || {}).forEach(([lang, vulns]) => {
        if (trends[lang]) {
          if (vulns.total !== undefined) {
            trends[lang].total.push({
              timestamp: scan.timestamp,
              count: vulns.total
            });
          }
          if (vulns.critical !== undefined) {
            trends[lang].critical.push({
              timestamp: scan.timestamp,
              count: vulns.critical
            });
          }
          if (vulns.high !== undefined) {
            trends[lang].high.push({
              timestamp: scan.timestamp,
              count: vulns.high
            });
          }
        }
      });
    });

    this.history.trends = trends;
  }

  saveHistory() {
    fs.writeFileSync(VULN_HISTORY_FILE, JSON.stringify(this.history, null, 2));
  }

  generateReport() {
    console.log('ðŸ“Š Vulnerability Report\n');
    console.log('='.repeat(60));

    const latest = this.history.scans[this.history.scans.length - 1];
    if (!latest) {
      console.log('No scan data available. Run a scan first.');
      return;
    }

    console.log(`\nLatest Scan: ${new Date(latest.timestamp).toLocaleString()}`);
    console.log(`Mode: ${latest.mode}\n`);

    Object.entries(latest.vulnerabilities || {}).forEach(([lang, vulns]) => {
      console.log(`\n${lang.toUpperCase()}:`);
      if (vulns.total !== undefined) {
        console.log(`  Total: ${vulns.total}`);
        if (vulns.critical !== undefined) {
          console.log(`  Critical: ${vulns.critical}`);
        }
        if (vulns.high !== undefined) {
          console.log(`  High: ${vulns.high}`);
        }
        if (vulns.moderate !== undefined) {
          console.log(`  Moderate: ${vulns.moderate}`);
        }
        if (vulns.low !== undefined) {
          console.log(`  Low: ${vulns.low}`);
        }
      }
    });

    // Show trends
    console.log('\n' + '='.repeat(60));
    console.log('\nTrends (Last 10 Scans):\n');

    const recentScans = this.history.scans.slice(-10);
    recentScans.forEach(scan => {
      const date = new Date(scan.timestamp).toLocaleDateString();
      const nodeVulns = scan.vulnerabilities?.nodejs?.total || 0;
      console.log(`  ${date}: ${nodeVulns} vulnerabilities`);
    });

    // Generate markdown report
    this.generateMarkdownReport();
  }

  generateMarkdownReport() {
    const reportFile = path.join(PROJECT_DIR, 'project/vulnerability-report.md');
    let content = '# Vulnerability Report\n\n';
    content += `**Generated:** ${new Date().toISOString()}\n`;
    content += `**Mode:** ${this.mode}\n\n`;

    const latest = this.history.scans[this.history.scans.length - 1];
    if (latest) {
      content += '## Latest Scan\n\n';
      content += `**Date:** ${new Date(latest.timestamp).toLocaleString()}\n\n`;

      Object.entries(latest.vulnerabilities || {}).forEach(([lang, vulns]) => {
        content += `### ${lang.toUpperCase()}\n\n`;
        if (vulns.total !== undefined) {
          content += `- **Total:** ${vulns.total}\n`;
          if (vulns.critical !== undefined) {
            content += `- **Critical:** ${vulns.critical}\n`;
          }
          if (vulns.high !== undefined) {
            content += `- **High:** ${vulns.high}\n`;
          }
        }
        content += '\n';
      });
    }

    content += '## Trend Analysis\n\n';
    content += 'See `project/vulnerability-history.json` for detailed trend data.\n';

    fs.writeFileSync(reportFile, content);
    console.log(`\nâœ… Report saved to: project/vulnerability-report.md`);
  }
}

// Main execution
if (require.main === module) {
  const args = process.argv.slice(2);
  const reportOnly = args.includes('--report');
  const dashboard = args.includes('--dashboard');

  const tracker = new VulnerabilityTracker();

  if (reportOnly) {
    tracker.generateReport();
  } else {
    tracker.scan().then(() => {
      tracker.generateReport();
    });
  }
}

module.exports = VulnerabilityTracker;
